Info file: emacs-lisp-intro-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs-lisp-intro.texi'
using `texinfmt.el' version 2.41 of  1 Mar 2005.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs Lisp Intro: (eintr).
			A simple introduction to Emacs Lisp programming.
END-INFO-DIR-ENTRY


これはプログラマではない人のための `Emacs Lisp プログラミング' 解説書で
ある．

Edition 2.04, 2001 Dec 17

Copyright (C) 1990, '91, '92, '93, '94, '95, '97, 2001 Free Software
Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Section being the Preface, with the Front-Cover Texts being
no Front-Cover Texts, and with the Back-Cover Texts being no
Back-Cover Texts.  A copy of the license is included in the section
entitled "GNU Free Documentation License".















File: emacs-lisp-intro-ja.info, Node: Top, Next: Preface, Prev: (dir), Up: (dir)

An Introduction to Programming in Emacs Lisp
********************************************

これはプログラマではない人のための `Emacs Lisp プログラミング' 解説書で
ある．

以下にあるメニューは各章のリストである．ここにはすべての章のすべての節
を一覧してある．

* Menu:

* PrePreface::                  訳者まえがき
* Preface::                     What to look for.
* List Processing::             What is Lisp?
* Practicing Evaluation::       Running several programs.
* Writing Defuns::              How to write function definitions.
* Buffer Walk Through::         Exploring a few buffer-related functions.
* More Complex::                A few, even more complex functions.
* Narrowing & Widening::        Restricting your and Emacs attention to
                                    a region.
* car cdr & cons::              Fundamental functions in Lisp.
* Cutting & Storing Text::      Removing text and saving it.
* List Implementation::         How lists are implemented in the computer.
* Yanking::                     Pasting stored text.
* Loops & Recursion::           How to repeat a process.
* Regexp Search::               Regular expression searches.
* Counting Words::              A review of repetition and regexps.
* Words in a defun::            Counting words in a `defun'.
* Readying a Graph::            A prototype graph printing function.
* Emacs Initialization::        How to write a `.emacs' file.
* Debugging::                   How to run the Emacs Lisp debuggers.
* Conclusion::                  Now you have the basics.
* the-the::                     An appendix: how to find reduplicated words.
* Kill Ring::                   An appendix: how the kill ring works.
* Full Graph::                  How to create a graph with labelled axes.
* GNU Free Documentation License::
* Index::
* About the Author::

 -- The Detailed Node Listing ---

Preface

* Why::                         Why learn Emacs Lisp?
* On Reading this Text::        Read, gain familiarity, pick up habits....
* Who You Are::                 For whom this is written.
* Lisp History::
* Note for Novices::            You can read this as a novice.
* Thank You::

List Processing

* Lisp Lists::                  What are lists?
* Run a Program::               Any list in Lisp is a program ready to run.
* Making Errors::               Generating an error message.
* Names & Definitions::         Names of symbols and function definitions.
* Lisp Interpreter::            What the Lisp interpreter does.
* Evaluation::                  Running a program.
* Variables::                   Returning a value from a variable.
* Arguments::                   Passing information to a function.
* set & setq::                  Setting the value of a variable.
* Summary::                     The major points.
* Error Message Exercises::

Lisp Lists

* Numbers Lists::               List have numbers, other lists, in them.
* Lisp Atoms::                  Elemental entities.
* Whitespace in Lists::         Formating lists to be readable.
* Typing Lists::                How GNU Emacs helps you type lists.

The Lisp Interpreter

* Complications::               Variables, Special forms, Lists within.
* Byte Compiling::              Specially processing code for speed.

Evaluation

* Evaluating Inner Lists::      Lists within lists...

Variables

* fill-column Example::
* Void Function::               The error message for a symbol
                                  without a function.
* Void Variable::               The error message for a symbol without a value.

Arguments

* Data types::                  Types of data passed to a function.
* Args as Variable or List::    An argument can be the value
                                  of a variable or list.
* Variable Number of Arguments::  Some functions may take a
                                  variable number of arguments.
* Wrong Type of Argument::      Passing an argument of the wrong type
                                  to a function.
* message::                     A useful function for sending messages.

Setting the Value of a Variable

* Using set::                   Setting values.
* Using setq::                  Setting a quoted value.
* Counting::                    Using `setq' to count.

Practicing Evaluation

* How to Evaluate::             Typing editing commands or `C-x C-e'
                                  causes evaluation.
* Buffer Names::                Buffers and files are different.
* Getting Buffers::             Getting a buffer itself, not merely its name.
* Switching Buffers::           How to change to another buffer.
* Buffer Size & Locations::     Where point is located and the size of
                                the buffer.
* Evaluation Exercise::

How To Write Function Definitions

* Primitive Functions::
* defun::                       The `defun' special form.
* Install::                     Install a function definition.
* Interactive::                 Making a function interactive.
* Interactive Options::         Different options for `interactive'.
* Permanent Installation::      Installing code permanently.
* let::                         Creating and initializing local variables.
* if::                          What if?
* else::                        If--then--else expressions.
* Truth & Falsehood::           What Lisp considers false and true.
* save-excursion::              Keeping track of point, mark, and buffer.
* Review::
* defun Exercises::

Install a Function Definition

* Effect of installation::
* Change a defun::              How to change a function definition.

Make a Function Interactive

* Interactive multiply-by-seven::  An overview.
* multiply-by-seven in detail::  The interactive version.

`let'

* Prevent confusion::
* Parts of let Expression::
* Sample let Expression::
* Uninitialized let Variables::

The `if' Special Form

* if in more detail::
* type-of-animal in detail::    An example of an `if' expression.

Truth and Falsehood in Emacs Lisp

* nil explained::               `nil' has two meanings.

`save-excursion'

* Point and mark::              A review of various locations.
* Template for save-excursion::

A Few Buffer--Related Functions

* Finding More::                How to find more information.
* simplified-beginning-of-buffer::  Shows `goto-char',
                                `point-min', and `push-mark'.
* mark-whole-buffer::           Almost the same as `beginning-of-buffer'.
* append-to-buffer::            Uses `save-excursion' and
                                `insert-buffer-substring'.
* Buffer Related Review::       Review.
* Buffer Exercises::

The Definition of `mark-whole-buffer'

* mark-whole-buffer overview::
* Body of mark-whole-buffer::   Only three lines of code.

The Definition of `append-to-buffer'

* append-to-buffer overview::
* append interactive::          A two part interactive expression.
* append-to-buffer body::       Incorporates a `let' expression.
* append save-excursion::       How the `save-excursion' works.

A Few More Complex Functions

* copy-to-buffer::              With `set-buffer', `get-buffer-create'.
* insert-buffer::               Read-only, and with `or'.
* beginning-of-buffer::         Shows `goto-char',
                                `point-min', and `push-mark'.
* Second Buffer Related Review::
* optional Exercise::

The Definition of `insert-buffer'

* insert-buffer code::
* insert-buffer interactive::   When you can read, but not write.
* insert-buffer body::          The body has an `or' and a `let'.
* if & or::                     Using an `if' instead of an `or'.
* Insert or::                   How the `or' expression works.
* Insert let::                  Two `save-excursion' expressions.

The Interactive Expression in `insert-buffer'

* Read-only buffer::            When a buffer cannot be modified.
* b for interactive::           An existing buffer or else its name.

Complete Definition of `beginning-of-buffer'

* Optional Arguments::
* beginning-of-buffer opt arg::  Example with optional argument.
* beginning-of-buffer complete::

`beginning-of-buffer' with an Argument

* Disentangle beginning-of-buffer::
* Large buffer case::
* Small buffer case::

Narrowing and Widening

* Narrowing advantages::        The advantages of narrowing
* save-restriction::            The `save-restriction' special form.
* what-line::                   The number of the line that point is on.
* narrow Exercise::

`car', `cdr', `cons': Fundamental Functions

* Strange Names::               An historical aside: why the strange names?
* car & cdr::                   Functions for extracting part of a list.
* cons::                        Constructing a list.
* nthcdr::                      Calling `cdr' repeatedly.
* nth::
* setcar::                      Changing the first element of a list.
* setcdr::                      Changing the rest of a list.
* cons Exercise::

`cons'

* Build a list::
* length::                      How to find the length of a list.

Cutting and Storing Text

* Storing Text::                Text is stored in a list.
* zap-to-char::                 Cutting out text up to a character.
* kill-region::                 Cutting text out of a region.
* Digression into C::           Minor note on C programming language macros.
* defvar::                      How to give a variable an initial value.
* copy-region-as-kill::         A definition for copying text.
* cons & search-fwd Review::
* search Exercises::

`zap-to-char'

* Complete zap-to-char::        The complete implementation.
* zap-to-char interactive::     A three part interactive expression.
* zap-to-char body::            A short overview.
* search-forward::              How to search for a string.
* progn::                       The `progn' special form.
* Summing up zap-to-char::      Using `point' and `search-forward'.

`kill-region'

* Complete kill-region::        The function definition.
* condition-case::              Dealing with a problem.
* delete-and-extract-region::   Doing the work.

Initializing a Variable with `defvar'

* See variable current value::
* defvar and asterisk::         An old-time convention.

`copy-region-as-kill'

* Complete copy-region-as-kill::  The complete function definition.
* copy-region-as-kill body::    The body of `copy-region-as-kill'.

The Body of `copy-region-as-kill'

* last-command & this-command::
* kill-append function::
* kill-new function::

How Lists are Implemented

* Lists diagrammed::
* Symbols as Chest::            Exploring a powerful metaphor.
* List Exercise::

Yanking Text Back

* Kill Ring Overview::          The kill ring is a list.
* kill-ring-yank-pointer::      The `kill-ring-yank-pointer' variable.
* yank nthcdr Exercises::

Loops and Recursion

* while::                       Causing a stretch of code to repeat.
* dolist dotimes::
* Recursion::                   Causing a function to call itself.
* Looping exercise::

`while'

* Looping with while::          Repeat so long as test returns true.
* Loop Example::                A `while' loop that uses a list.
* print-elements-of-list::      Uses `while', `car', `cdr'.
* Incrementing Loop::           A loop with an incrementing counter.
* Decrementing Loop::           A loop with a decrementing counter.

A Loop with an Incrementing Counter

* Incrementing Example::        Counting pebbles in a triangle.
* Inc Example parts::           The parts of the function definition.
* Inc Example altogether::      Putting the function definition together.

Loop with a Decrementing Counter

* Decrementing Example::        More pebbles on the beach.
* Dec Example parts::           The parts of the function definition.
* Dec Example altogether::      Putting the function definition together.

Save your time: `dolist' and `dotimes'

* dolist::
* dotimes::

Recursion

* Building Robots::             Same model, different serial number ...
* Recursive Definition Parts::  Walk until you stop ...
* Recursion with list::         Using a list as the test whether to recurse.
* Recursive triangle function::
* Recursion with cond::
* Recursive Patterns::          Often used templates.
* No Deferment::                Don't store up work ...
* No deferment solution::

Recursion in Place of a Counter

* Recursive Example arg of 1 or 2::
* Recursive Example arg of 3 or 4::

Recursive Patterns

* Every::
* Accumulate::
* Keep::

Regular Expression Searches

* sentence-end::                The regular expression for `sentence-end'.
* re-search-forward::           Very similar to `search-forward'.
* forward-sentence::            A straightforward example of regexp search.
* forward-paragraph::           A somewhat complex example.
* etags::                       How to create your own `TAGS' table.
* Regexp Review::
* re-search Exercises::

`forward-sentence'

* Complete forward-sentence::
* fwd-sentence while loops::    Two `while' loops.
* fwd-sentence re-search::      A regular expression search.

`forward-paragraph': a Goldmine of Functions

* forward-paragraph in brief::  Key parts of the function definition.
* fwd-para let::                The `let*' expression.
* fwd-para while::              The forward motion `while' loop.
* fwd-para between paragraphs::  Movement between paragraphs.
* fwd-para within paragraph::   Movement within paragraphs.
* fwd-para no fill prefix::     When there is no fill prefix.
* fwd-para with fill prefix::   When there is a fill prefix.
* fwd-para summary::            Summary of `forward-paragraph' code.

Counting: Repetition and Regexps

* Why Count Words::
* count-words-region::          Use a regexp, but find a problem.
* recursive-count-words::       Start with case of no words in region.
* Counting Exercise::

The `count-words-region' Function

* Design count-words-region::   The definition using a `while' loop.
* Whitespace Bug::              The Whitespace Bug in `count-words-region'.

Counting Words in a `defun'

* Divide and Conquer::
* Words and Symbols::           What to count?
* Syntax::                      What constitutes a word or symbol?
* count-words-in-defun::        Very like `count-words'.
* Several defuns::              Counting several defuns in a file.
* Find a File::                 Do you want to look at a file?
* lengths-list-file::           A list of the lengths of many definitions.
* Several files::               Counting in definitions in different files.
* Several files recursively::   Recursively counting in different files.
* Prepare the data::            Prepare the data for display in a graph.

Count Words in `defuns' in Different Files

* lengths-list-many-files::     Return a list of the lengths of defuns.
* append::                      Attach one list to another.

Prepare the Data for Display in a Graph

* Sorting::                     Sorting lists.
* Files List::                  Making a list of files.
* Counting function definitions::

Readying a Graph

* Columns of a graph::
* graph-body-print::            How to print the body of a graph.
* recursive-graph-body-print::
* Printed Axes::
* Line Graph Exercise::

Your `.emacs' File

* Default Configuration::
* Site-wide Init::              You can write site-wide init files.
* defcustom::                   Emacs will write code for you.
* Beginning a .emacs File::     How to write a `.emacs file'.
* Text and Auto-fill::          Automatically wrap lines.
* Mail Aliases::                Use abbreviations for email addresses.
* Indent Tabs Mode::            Don't use tabs with TeX
* Keybindings::                 Create some personal keybindings.
* Keymaps::                     More about key binding.
* Loading Files::               Load (i.e., evaluate) files automatically.
* Autoload::                    Make functions available.
* Simple Extension::            Define a function; bind it to a key.
* X11 Colors::                  Colors in version 19 in X.
* Miscellaneous::
* Mode Line::                   How to customize your mode line.

Debugging

* debug::                       How to use the built-in debugger.
* debug-on-entry::              Start debugging when you call a function.
* debug-on-quit::               Start debugging when you quit with `C-g'.
* edebug::                      How to use Edebug, a source level debugger.
* Debugging Exercises::

Handling the Kill Ring

* rotate-yank-pointer::         Move a pointer along a list and around.
* yank::                        Paste a copy of a clipped element.
* yank-pop::                    Insert first element pointed to.

The `rotate-yank-pointer' Function

* Understanding rotate-yk-ptr::
* rotate-yk-ptr body::          The body of `rotate-yank-pointer'.

The Body of `rotate-yank-pointer'

* Digression concerning error::  How to mislead humans, but not computers.
* rotate-yk-ptr else-part::     The else-part of the `if' expression.
* Remainder Function::          The remainder, `%', function.
* rotate-yk-ptr remainder::     Using `%' in `rotate-yank-pointer'.
* kill-rng-yk-ptr last elt::    Pointing to the last element.

`yank'

* rotate-yk-ptr arg::           Pass the argument to `rotate-yank-pointer'.
* rotate-yk-ptr negative arg::  Pass a negative argument.

A Graph with Labelled Axes

* Labelled Example::
* print-graph Varlist::         `let' expression in `print-graph'.
* print-Y-axis::                Print a label for the vertical axis.
* print-X-axis::                Print a horizontal label.
* Print Whole Graph::           The function to print a complete graph.

The `print-Y-axis' Function

* Height of label::             What height for the Y axis?
* Compute a Remainder::         How to compute the remainder of a division.
* Y Axis Element::              Construct a line for the Y axis.
* Y-axis-column::               Generate a list of Y axis labels.
* print-Y-axis Penultimate::    A not quite final version.

The `print-X-axis' Function

* Similarities differences::    Much like `print-Y-axis', but not exactly.
* X Axis Tic Marks::            Create tic marks for the horizontal axis.

Printing the Whole Graph

* The final version::           A few changes.
* Test print-graph::            Run a short test.
* Graphing words in defuns::    Executing the final code.
* lambda::                      How to write an anonymous function.
* mapcar::                      Apply a function to elements of a list.
* Another Bug::                 Yet another bug ... most insidious.
* Final printed graph::         The graph itself!




File: emacs-lisp-intro-ja.info, Node: PrePreface, Next: Preface, Prev: Top, Up: Top

訳者まえがき
************

本書は、「Programming in Emacs Lisp: An Introduction」（texinfoファイル
`emacs-lisp-intro.texi'、2.04版）の翻訳である。

ASCIIにより「Programming in Emacs Lisp: An Introduction」（texinfoファ
イル`emacs-lisp-intro.texi'、1.05版、更新日1997年10月21日）の翻訳が

     http://www.ascii.co.jp/pub/GNU/emacs-lisp-intro-jp.texi

でGPLで公開されており、2.04版へのアップデートを行っているものです。日本
語訳をGPLにて公開されているASCIIに感謝いたします。

日本語のTeXが利用できる環境ならば、`texi2dvi'などのコマンドで自前でdvi
ファイルを作成して印刷できる。また、Muleを用いてバッファに読み込んでか
ら`M-x texinfo-format-buffer'を実行すれば、日本語版のinfoファイルを作成
することもできる。ただし、このようにして作ったinfoファイルでは、（メ
ニューなどの）info特有の部分は未翻訳であることをあらかじめご了承願いた
い。

Mule（Multilingual Enhancement to GNU Emacs）とそのLispは、多国語を扱う
ために拡張したため、GNU EmacsやEmacs Lispと互換ではない部分がある。詳し
くはMuleのディストリビューションに含まれる`mule-jp.texi'や`マルチリンガ
ル環境の実現' (1) (*Note PrePreface-Footnotes::) （特に第3章「Muleによ
るマルチリンガル環境の実現」）を参照してほしい。なお、本書の例題は、英
数字を使用する限りはそのまま動作する。

GNU Emacsが扱う（7ビットの）ASCIIコードの文字は、コンピュータ内部では1
文字を1バイトで表現し、これらの文字は画面上の表示でも1文字あたり1コラム
を占める。したがって、文字数、内部表現のバイト数、表示コラム数のどれを
とっても同じ値である。また、テキストをファイルに収めたときの文字コード
とGNU Emacsのバッファ内での文字コードはまったく同じである。

ところが、多国語を扱うMuleでは、こうはならない。各国ごとにその国の文字
を1バイトあるいは2バイトで表す規格がある。たとえば、日本には文字コード
の規格としてJIS X 0208があり2バイトで1文字を表す。また、ローマ字とカタ
カナの規格としてJIS X 0201があり1バイトで1文字を表す。

1つのバッファ内に複数の国の文字コードが混在してもよいように、Muleでは1
バイトないしは2バイトの文字コードのまえに識別用に1バイト（ないしは2バイ
ト）を付加してバッファ内に保持する。この識別用のバイトを*リーディングキャ
ラクタ（leading character）*と呼ぶ。ただし、7ビットのASCIIコードの文字
は、GNU Emacsと同じで、リーディングキャラクタは付加しない。

たとえば、日本語の「あ」は、文字数は1であるが、内部表現には3バイト必要
であり、表示には2コラム必要である。半角の「ア」は、文字数は1であるが、
内部表現には2バイト必要であり、表示には1コラム必要である。ASCII文字の
「a」は、文字数も内部表現のバイト数も表示コラム数も1である。

このため、Muleでは、関数 `length' （*Note length::）は、文字列の「文字
数」ではなく、内部表現の「バイト数」を返す。バッファ内のポイントやマー
ク（*Note Buffer Size & Locations::）の位置も、「文字数」ではなく内部表
現の「バイト数」が単位である。

一方、関数`forward-char'は、その名前から予想されるように、文字単位でポ
イントを移動する。文字列の「文字数」を調べるには関数`chars-in-string'を
使い、「表示コラム数」を調べるには関数`string-width'を使う。

     (length          "abcあいう")     => 12
     (chars-in-string "abcあいう")     =>  6
     (string-width    "abcあいう")     =>  9

`.emacs'（*Note Emacs Initialization::）でMuleの版を区別するには、関数
`mule-version'が返す文字列を使う。また、日本語入力に「Wnn」、「sj3」、
「かんな」のどれが使えるかを判別し、それぞれに固有の設定を行うには、関
数`featurep'を使ってつぎのようにする。

     (if (and (not (featurep 'egg)) (featurep 'canna))
         (progn 「かんな」に固有の設定 ... ))

     (if (and (featurep 'egg) (featurep 'wnn-egg))
         (progn 「WNN」に固有の設定 ... ))

     (if (and (featurep 'egg) (featurep 'sj3-egg))
         (progn 「SJ3」に固有の設定 ... ))

MuleがX Window Systemのクライアントとして動作している場合、変数
`window-system'には値`x'が、そうでない場合には`nil'が束縛されるので、つ
ぎのように判別できる。

     (if (eq window-system 'x)
         (progn 「X WINDOW SYSTEM」に固有の設定 ...)
       画面端末の場合の設定 ...)




File: emacs-lisp-intro-ja.info  Node: PrePreface-Footnotes, Up: PrePreface

(1) ISBN4-88735-020-1、株式会社プレンティスホール出版


File: emacs-lisp-intro-ja.info, Node: Preface, Next: List Processing, Prev: PrePreface, Up: Top

はじめに
********

統合環境GNU Emacsの大部分はEmacs Lispと呼ばれるプログラミング言語で書か
れている。このプログラミング言語で書いたコードは、ユーザーが指令を与え
たときに何をすべきかをコンピュータに指示するソフトウェア（一連の命令）
である。Emacsは、Emacs Lispで新たにコードを書いてエディタの拡張機能とし
て簡単に追加できるように設計されている。

（Emacsは時折拡張可能なエディタ呼ばれるが、それ以上の能力を有している。
したがって、「拡張可能な計算環境」と呼ぶのがいいが、少々いいづらい。もっ
と単純にエディタと呼ぶのがいいだろう。マヤ暦や月の満ち欠けを調べたり、
多項式を簡約化したり、コードをデバッグしたり、ファイルを管理したり、手
紙を読んだり、本を書いたりなどのEmacsで行えるすべてのことは、もっとも一
般的な意味で編集である。）

Emacs Lispはテキストエディタに関連付けて考えられがちであるが、それ自体
で1つのプログラミング言語である。他のプログラミング言語と同様に使える。

プログラミングを理解したい、Emacsを拡張したい、プログラマになりたいとい
う読者もいることであろう。Emacs Lispの入門である本書は、プログラミング
の基本を学ぶための指針を与え、さらに重要なことは、自力で学習する方法を
示すために執筆したものである。

* Menu:

* Why::                         Why learn Emacs Lisp?
* On Reading this Text::        Read, gain familiarity, pick up habits....
* Who You Are::                 For whom this is written.
* Lisp History::
* Note for Novices::            You can read this as a novice.
* Thank You::



File: emacs-lisp-intro-ja.info, Node: Why, Next: On Reading this Text, Prev: Preface, Up: Preface

Why Study Emacs Lisp?
=====================

Emacs Lisp は大抵Emacsとだけ関連付けられているが、これは完全なプログラ
ム言語である。Emacs Lispを他のプログラム言語と同様に使うことができるの
だ。

おそらくEmacsを拡張するためやプログラマになりたいという目的でプログラミ
ングを理解しようとしているだろう。この文書はプログラミングを始め、その
基礎を学び、さらに重要な自分自身で学ぶ方法を紹介している。



File: emacs-lisp-intro-ja.info, Node: On Reading this Text, Next: Who You Are, Prev: Why, Up: Preface

On Reading this Text
====================

本書には、Emacsで実行できる小さな例題プログラムがある。GNU EmacsのInfo
で読んでいる場合には、例題プログラムに出会うたびにそれらを実行できる
（これは簡単に実行できるが、その方法は例題をあげたときに説明する）。あ
るいは、Emacsが動いているコンピュータを脇に置いて、印刷された本書を読ん
でいる場面もあろう（これは、筆者の好みでもある。筆者は印刷した書物が好
きである）。手もとでEmacsを実行できなくても本書を読む意味はある。ただし、
そのような場合には、小説や初めての国への旅行案内とみなしてほしい。興味
深いはずであるが、実際にそこにいるのとは異なる。

本書の大部分は、GNU Emacsで使っているコードを眺める、つまり、ウォークス
ルーであり、ガイド付きツアーである。これらのツアーには2つの目的がある。
第一に、実際に動作する（日常的に使用している）コードに慣れてもらうこと
であり、第二に、Emacsの動作方式に慣れてもらうことである。統合環境の実装
方式を学ぶことは興味深いはずである。また、ソースコードを読み進む際のコ
ツも学んでほしい。ソースコードから学んだり、アイデアを堀り起こせるはず
である。GNU Emacsはまさに宝の山である。

エディタとしてのEmacsやプログラミング言語としてのEmacs Lispを学ぶことに
加えて、例題やガイド付きツアーは、Lispのプログラミング環境としての
Emacsを熟知する機会となるはずである。GNU Emacsは、プログラミングの支援
に加えて、`M-.'  （コマンド`find-tag'を起動するキー）などの慣れると便利
なツールも提供する。環境の一部であるバッファやその他のオブジェクトにつ
いても学ぶ。Emacsのこれらの機能を学ぶことは、読者の街の周りの道を新たに
学ぶことに似ている。


読者が知らないプログラミングの側面を学ぶためのEmacsの利用法も伝えたいと
思う。読者を惑わすことがらを理解したり、新たなことを行う方法を調べるた
めにもEmacsを利用できるのである。この独立性は好ましいだけでなく利点でも
ある。



File: emacs-lisp-intro-ja.info, Node: Who You Are, Next: Lisp History, Prev: On Reading this Text, Up: Preface

対象とする読者
==============

本書は、プログラマではない人向けの初歩の入門書である。すでにプログラマ
である読者には、本書は物足りないであろう。というのは、そのような読者は
すでにリファレンスマニュアルを存分に読めるようになっており、本書の構成
は間延びして見えるであろう。

経験あるプログラマは、本書をつぎのように評価してくれた。

     リファレンスマニュアルで学ぶほうが好きである。各段落に「飛び込ん
     で」、段落のあいだで「息つぎ」する。

     段落を読み終えたときには、そこで取り上げた話題は完結しており、必要
     なことは（以降の段落でより詳しく説明する場合を除いて）すべてわかっ
     たと仮定したい。よく構成されたリファレンスマニュアルには、冗長な部
     分がなく、必要な情報への索引が整備されているはずである。

本書は、このような人向けではない！

第一に、おのおののことがらを少なくとも3回は説明するように努めた。1回目
は紹介、2回目は使い方、3回目は別の使い方や復習である。

第二に、1つの話題に関するすべての情報を1か所にまとめることはせずに、1つ
の段落に詰め過ぎないようにした。  筆者の考え方では、そうしないと読者に
重荷を背負わせることになるからである。かわりに、その時点で必要なことの
みを説明するように努めた（あとで詳しく説明する場合に備えて、少々余分に
説明する場面もある）。

1回読むだけで、すべてを理解してもらえるとは考えていない。読者は、説明内
容を「わかったつもり」にしておく必要があるだろう。重要なことがらを正し
く読者に指し示し、注意を促すように本書を構成したつもりである。

いくつかの段落には、「飛び込んで」もらうしかなく、それ以外に読み進む方
法はない。しかし、そのような段落の個数は少なくするように努めた。本書は
登頂困難な山ではなく、楽に歩ける小山である。

本書`Emacs Lispプログラミング'入門には、姉妹編と呼ぶべきドキュメント
*Note The GNU Emacs Lisp Reference Manual: (elisp)Top.  がある。リファ
レンスマニュアルには本書より詳しい説明がある。リファレンスマニュアルで
は、1つの話題に関する情報は1か所にすべてまとめてある。上で述べたような
プログラマは、そちらを参照すべきである。もちろん、本書を読み終えて自分
のプログラムを書くときには、`リファレンスマニュアル'が有用であるはずで
ある。



File: emacs-lisp-intro-ja.info, Node: Lisp History, Next: Note for Novices, Prev: Who You Are, Up: Preface

Lispの歴史
==========

Lispは、人工知能の研究のために、1950年代末にマサチューセッツ工科大学で
初めて開発された。Lisp言語はその強力な機能のため、エディタコマンドや統
合環境を書くなどの他の目的にも優れている。

GNU Emacs Lispは、1960年代にMITで開発されたMaclispから多くを受け継いで
いる。1980年代に標準規格となったCommon Lispからも一部を受け継いでいる。
しかし、Emacs Lispは、Common Lispよりもずっと単純である（Emacsの標準ディ
ストリビューションには、Common Lispの多くの機能をEmacs Lispに追加するた
めの機能拡張用ファイル`cl.el'がある）。



File: emacs-lisp-intro-ja.info, Node: Note for Novices, Next: Thank You, Prev: Lisp History, Up: Preface

初心者へ一言
============

GNU Emacsを知らない読者にも、本書は有益であろう。しかし、たとえスクリー
ンの移動方法だけであってもEmacsを学ぶことを勧める。Emacsの使い方は、オ
ンラインのチュートリアルで自習できる。それには、`C-h t'とタイプする（つ
まり、CTRLキーと`h'を同時に押してから離し、さらに、`t'を押してから離
す）。

Emacsの標準コマンドを参照するために、`M-C-\'（`indent-region'）のように、
コマンドを起動するために押すキーに続けて括弧内にコマンド名を書く。つま
り、コマンド`indent-region'は、慣習的には`M-C-\'とタイプすると起動でき
ることを意味する（望むならば、コマンドを起動するためのキーを変更するこ
ともできる。これを"リバインド（rebinding）"という。*Note Keymaps::）。
`M-C-\'は、METAキー、CTRLキー、\キーの3つを同時に押すことを意味する(最
近のキーボードはMETA キーが ALT と印字されている)。ピアノを演奏するとき
の和音になぞらえて、このような組み合わせをキーコード（keychord）と呼ぶ
こともある。METAキーがないキーボードでは、かわりにESCキーを前置キーとし
て使う。このような場合には、`M-C-\'は、ESCキーを押して離してから、CTRL
キーと\キーの2つを同時に押すことを意味する。しかし、`M-C-\' は大抵CTRL
キーとALT と \ を同時に押すことを意味する。

キーコードに加えて、`C-u'とともにキー入力したものを与えることがで
きる。これを「universal argument」と呼ぶ。`C-u'は続くコマンドに引
数を渡す働きをする。それゆえ、6個のスペースでテキストのあるリージョン
をインデントすることが、リージョンを選択し、`C-u 6 M-C-\' を入
力することで可能となる(数字を指定しなければ、Emacsはコマンドに4を渡す
かコマンドをデフォルトとは違うように働かせる)。
*Note Numeric Arguments: (emacs)Arguments 参照。

GNU EmacsのInfoで読んでいる場合には、スペースバーSPCを押すだけで全体を
読み進められる（Infoについて学ぶには、`C-h i'とタイプしてInfoを選択すれ
ばよい）。

用語に関しての注意：単語Lispのみを使った場面ではLispのさまざまな方言全
般を意味するが、Emacs Lispを使った場面ではGNU Emacs Lispのみを意味する。



File: emacs-lisp-intro-ja.info, Node: Thank You, Prev: Note for Novices, Up: Preface

謝　辞
======

本書の執筆に協力していただいた方々に感謝したい。
特に、Jim Blandy、Noah Friedman、Jim Kingdon、Roland McGrath、
Frank Ritter、Randy Smith、Richard M. Stallman、
Melissa Weisshausに感謝したい。
辛抱強く励ましてくれたPhilip JohnsonとDavid Stampeにも感謝したい。
誤りがあれば筆者の責任である。

                                                    Robert J. Chassell







File: emacs-lisp-intro-ja.info, Node: List Processing, Next: Practicing Evaluation, Prev: Preface, Up: Top

リスト処理
**********

慣れていない人の目には、Lispは不可思議なプログラミング言語である。Lisp
のコードには、いたるところに括弧がある。「Lots of Isolated Silly
Parentheses（奇妙な括弧が多い）」の略であると批判する人達もいる。しかし、
この批判は不当である。LispはLISt Processingの略であり、括弧で囲んだ*リ
スト（list）* （および、リストのリスト）を扱うプログラミング言語である。
括弧はリストの境界を表す。リストの直前にアポストロフィ、つまり、引用符
`''を付ける場合もある。リストはLispの基本である。

* Menu:

* Lisp Lists::                  What are lists?
* Run a Program::               Any list in Lisp is a program ready to run.
* Making Errors::               Generating an error message.
* Names & Definitions::         Names of symbols and function definitions.
* Lisp Interpreter::            What the Lisp interpreter does.
* Evaluation::                  Running a program.
* Variables::                   Returning a value from a variable.
* Arguments::                   Passing information to a function.
* set & setq::                  Setting the value of a variable.
* Summary::                     The major points.
* Error Message Exercises::



File: emacs-lisp-intro-ja.info, Node: Lisp Lists, Next: Run a Program, Prev: List Processing, Up: List Processing

Lispのリスト
============

Lispでは、リストを`'(rose violet daisy buttercup)'のように書く。このリ
ストの直前にはアポストロフィが1つ付いている。これはつぎのように書くこと
もでき、こちらの書き方にも慣れてほしい。

     '(rose
       violet
       daisy
       buttercup)

このリストの各要素は異なる4つの花の名前である。個々の要素を空白で区切り、
庭の花を石で囲うように括弧で囲む。

* Menu:

* Numbers Lists::               List have numbers, other lists, in them.
* Lisp Atoms::                  Elemental entities.
* Whitespace in Lists::         Formating lists to be readable.
* Typing Lists::                How GNU Emacs helps you type lists.



File: emacs-lisp-intro-ja.info, Node: Numbers Lists, Next: Lisp Atoms, Prev: Lisp Lists, Up: Lisp Lists

Numbers, Lists inside of Lists
------------------------------

Lispでは、データとプログラムのどちらも同じ方法で表現する。つまり、どち
らも、単語や数やリストを空白で区切って括弧で囲んだリストである（プログ
ラムはデータのようにも見えるので、プログラムは容易に他のプログラムのデー
タとなりえる。これは、Lispの強力な機能である）。

（原文の2つの括弧書き(Since a program looks like data, one program may
easily serve as data for another; this is a very powerful feature of
Lisp.)  や(Incidentally, these two parenthetical remarks are *not*
Lisp lists, because they contain `;' and `.' as punctuation marks.)  に
は、句読点記号として`;'や`.'が含まれるのでLispのリストでは*ない*。）

つぎもリストの例であり、リストの中にリストを含む。

     '(this list has (a list inside of it))

このリストの要素は、`this'、`list'、`has'の単語と、リスト`(a list
inside of it)'である。内側のリストは、`a'、`list'、`inside'、`of'、
`it'の単語からできている。



File: emacs-lisp-intro-ja.info, Node: Lisp Atoms, Next: Whitespace in Lists, Prev: Numbers Lists, Up: Lisp Lists

Lispのアトム
------------

Lispでは、これまで単語と呼んできたものを"アトム（atoms）"と呼ぶ。この用
語はアトム（原子）の歴史的な意味からきており、「不可分」ということであ
る。Lispに関していえば、リストに用いてきた単語はそれ以上には小さく分割
できず、プログラムの一部として同じものを意味する。数や`+'のような1文字
の記号についてもそうである。一方、アトムとは異なり、リストは部分に分割
できる（*Note car cdr & cons::）。

リストでは、アトムを空白で区切る。アトムは、括弧のすぐ隣にあってもよい。

技術的には、Lispのリストは、空白で区切ったアトムを囲む括弧、リストを囲
む括弧、アトムやリストを囲む括弧から成る。リストは、たった1個のアトムを
含むだけでも、まったく含まなくてもよい。何も含まないリストは`()'のよう
に書き、"空リスト（empty list）"と呼ぶ。空リストは、それ以外のものとは
異なり、アトムであると同時にリストでもある。

アトムやリストを表示したものを"シンボリック式（symbolic expressions）"、
あるいは、より簡素には"S式（s-expressions）"と呼ぶ。用語「"式
（expression）"」そのものでは、表示したアトムやリスト、あるいは、コン
ピュータ内部に格納したアトムやリストを意味する。しばしば、これらを区別
せずに用語「"式（expression）"」を使う（さらに、多くの書籍では式の同義
語として用語「"フォーム（form）"」を使う）。

われわれの宇宙を構成するアトム（原子）は、それらが不可分であると考えら
れた時代に命名されたものであるが、物質原子は不可分ではないことが知られ
ている。原子の一部を分割したり、ほぼ同じ大きさに分裂させたりできる。物
質原子は、その真の性質が発見される以前に命名されたのである。Lispでは、
配列などのある種のアトムは構成部分に分割できるが、この分割機構はリスト
を分割する機構とは異なる。リスト操作に関する限り、リストのアトムは分割
できない。

英語の場合と同様に、Lispのアトムを構成する文字は、単語を作り上げる個々
の文字とは異なる。たとえば、南米のナマケモノを表す単語`ai'（ミツユビナ
マケモノ）は、2つの単語`a'と`i'とはまったく異なる。

自然界には多種類の原子が存在するが、Lispには数種類のアトムしかない。た
とえば、37、511、1729などの"数（numbers）"、`+'、`foo'、`forward-line'
などの"シンボル（symbols）"である。これまで例にあげた単語はすべてシンボ
ルである。Lispの日常の習慣では、用語「アトム」をあまり使わない。という
のは、プログラマは扱っているアトムの種類を特定しようとするからである。
Lispのプログラミングでは、リスト内のシンボル（やときには数）を扱う（括
弧書き「（やときには数）」の原文`(and sometimes numbers)'は、アトムを空
白で区切って括弧で囲んであり、しかも、Lispの句読点記号以外は含まないの
でLispのリストである）。

さらに、二重引用符で囲まれたテキストは（文であろうと段落であろうと）ア
トムである。つぎに例を示す。

     '(this list includes "text between quotation marks.")

Lispでは、句読点記号や空白を含みこのように囲まれたテキストは単一のアト
ムである。この種のアトムは"文字列（string）"と呼ばれ、コンピュータが人
間向けに出力するメッセージに使う。文字列は、数やシンボルとは異なる別の
種類のアトムであり、使い方も異なる。



File: emacs-lisp-intro-ja.info, Node: Whitespace in Lists, Next: Typing Lists, Prev: Lisp Atoms, Up: Lisp Lists

リスト内の空白
--------------

リスト内の空白の個数はいくつでもよい。Lisp言語の視点からすれば、

     '(this list
        looks like this)

は、つぎとまったく同等である。

     '(this list looks like this)

どちらの例もLispにとっては同じリストであり、`this'、`list'、`looks'、
`like'、`this'のシンボルからこの順に構成されたリストである。

余分な空白や改行は人間がリストを見やすくするためのものである。Lispが式
を読み取るとき、余分な空白をすべて取り除く（ただし、アトムとアトムのあ
いだには、これらを区切るために少なくとも1つの空白が必要である）。

奇妙に思えるかもしれないが、これまでの例で、Lispのすべてのリストがどの
ようなものであるかを見てきた。Lispのリストは多かれ少なかれこれまでの例
のようなものであり、もっと長かったり複雑なだけである。要約すれば、リス
トは括弧で囲まれたものであり、文字列は二重引用符で囲まれたものであり、
シンボルは単語のようなものであり、数は数字列である（鈎括弧やドットや特
別な数種の文字を使う場合もあるが、しばらくはこれらを使わない）。



File: emacs-lisp-intro-ja.info, Node: Typing Lists, Prev: Whitespace in Lists, Up: Lisp Lists

GNU Emacsのリスト入力補佐機能
-----------------------------

GNU EmacsのLisp InteractionモードやEmacs LispモードでLispの式を入力する
時には、Lispの式を読みやすく整形するためのコマンドを利用できる。たとえ
ば、TABキーを押すと、カーソルを置いた行を自動的に字下げする。あるリージョ
ンのコードを正しく字下げするコマンドは、慣習的に`M-C-\'にバインドされて
いる。リストの各要素が、どのリストに属するかがわかりやすくなるように字
下げする。つまり、内側のリストの各要素は、そのリストを囲むリストの要素
よりも字下げされる。

さらに、閉じ括弧をタイプするとEmacsは対応する開き括弧に一時的にカーソル
を移動して、対応関係がわかるようにする。Lispに与える個々のリストは括弧
の対応が取れている必要があるので、これはとても便利である(*Note Major
Modes: (emacs)Major Modes, for more information about Emacs' modes.)



File: emacs-lisp-intro-ja.info, Node: Run a Program, Next: Making Errors, Prev: Lisp Lists, Up: List Processing

プログラムの実行
================

Lispのどんなリストも実行できるプログラムである。それを実行する（Lispの
専門用語では"評価（evaluate）"する）と、コンピュータは、つぎの3つのうち
の1つを行う。リストそのものを返して、それ以外のことは何もしない。エラー
メッセージを出す。リストの先頭シンボルをなんらかのコマンドとして扱う
（もちろん、普通は3番目の動作を望む！）。

前節の例においてリストの直前に付けた1つのアポストロフィ`''を"クオート
（quote）"と呼ぶ。リストの直前にこれを付けると、そのリストに関しては何
もせずに字面どおりに扱うことをLispに指示する。リストの直前にクオートが
ない場合には、リストの先頭要素を特別扱いし、コンピュータが従うべきコマ
ンドとなる（Lispでは、これらのコマンドを*関数（functions）*と呼ぶ）。ま
えにあげたリスト`(+ 2 2)'の直前にはクオートがないので、Lispは、`+'がリ
ストの残りの部分に対して行うべき操作であると解釈し、後続の数を加算する。

GNU EmacsのInfoで読んでいる場合には、つぎのようにしてリストを評価する。
つぎのリストの閉じ括弧の直後にカーソルを置いてから`C-x C-e'とタイプする。

     (+ 2 2)

エコー領域に数`4'が表示されるはずである（専門用語では、たったいま「リス
トを評価」したのである。エコー領域とは画面の最下行のことで、テキストを
表示する場所である）。クオートしたリストについても同じことをやってみよ
う。つぎのリストの直後にカーソルを置いて`C-x C-e'とタイプする。

     '(this is a quoted list)

エコー領域に`(this is a quoted list)'と表示されるはずである。

いずれの場合も、GNU Emacsの内部にある"Lispインタープリタ（Lisp
interpreter）"と呼ばれるプログラムに指令、つまり、式を評価せよという指
令を与えたのである。Lispインタープリタという名称は、表現の意味を追いか
ける人間の仕事、つまり、通訳（interpreter）からきている。

リストの一部ではないアトム、つまり、括弧に囲まれていないアトムを評価す
ることもできる。この場合もLispインタープリタは人間が読める表現をコン
ピュータの言語に変換する。このこと（*Note Variables::）を説明するまえに、
まちがいを起こした場合にLispインタープリタがどうするかを説明しよう。



File: emacs-lisp-intro-ja.info, Node: Making Errors, Next: Names & Definitions, Prev: Run a Program, Up: List Processing

エラーメッセージの生成
======================

偶然引き起こした場合は気にしないでよいが、ここではエラーメッセージを生
成するようなコマンドをLispインタープリタに与えてみる。これは無害であり、
意図してエラーメッセージを生成することにある。専門用語を理解すれば、エ
ラーメッセージは有益でさえある。「エラー」メッセージと呼ぶよりは「ヘル
プ」メッセージと呼ぶべきであろう。これらは、見知らぬ国を訪れた旅行者の
ための道標のようなものである。読みこなすのはたいへんであろうが、いった
ん理解してしまえば道を指し示してくれる。

エラーメッセージはEmacsに組み込まれたデバッガにより表示されます。

リストの先頭要素に意味のあるコマンドもなく、クオートもしていないリスト
を評価してみよう。上で用いたリストとほとんど同じであるが、その直前には
引用符を付けない。このリストの直後にカーソルを置いて`C-x C-e'とタイプす
る。

     (this is an unquoted list)

どのように結果が表示されるかはEmacsのバージョンに依存します。Emacs 21
ではEmacs 20やそれ以前のものよりも多くの情報が表示されます。まず、最近
のEmacsでのエラーを、次にEmacs 20でのエラーを紹介します。

Emacs 21では `*Backtrace*' ウィンドウが開き、そこに以下のようなメッセー
ジが表示されます。

     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function this)
       (this is an unquoted list)
       eval((this is an unquoted list))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------

カーソルはこのウィンドウへ移ります (表示されるまで数秒かかるかもしれま
せん)。デバッガを停止させ、そこから抜けるために、以下を入力します。

     q

すぐに `q' を押してください。そうすれば、デバッガから抜けることができま
す。それから、`C-x C-e' で再度評価すると、またデバッガに入ります。

すでに知っていることをもとにすれば、このエラーメッセージのほとんどを理
解できるでしょう。

`*Backtrace*' バッファは下から読んでいきます。それがEmacsが実行した順番
になるのです。`C-x C-e' を入力すると、`eval-last-sexp' を対話的に呼び出
します。`eval'は「evaluate(評価する)」の、`sexp' は「symbolic
expression(シンボリック式)」の略称です。結局、このコマンドは「最後のシ
ンボリック式を評価する」ことを意味します。つまり、カーソルの直前の式が
評価されるのです。

各行は次にどの式が評価されるかを表しています。Emacsが行ったことを逆方向
に(エラーのある行から遡って)確認することができることから、このバッファ
を`*Backtrace*'バッファと呼んでいます。`*Backtrace*'

`*Backtrace*' バッファの最初の行は以下のようになっています。

     Debugger entered--Lisp error: (void-function this)

Lispインタープリタはリストのアトムである`this'という単語を評価しようと
します。これにより、`void-function this' (this という関数は未定義)とい
うエラーメッセージが表示されます。

このメッセージには`void-function' と `this' という単語が含まれます。

`function' は以前に取り上げました。これは重要な用語である。ここでは、"
関数（function）"とは、コンピュータに何かを行わせるためのコンピュータに
対する一連の命令であると定義しよう

これで`void-function this' というエラーメッセージを理解することができま
す。関数(つまり、`this'という単語) にはコンピュータに実行させるための命
令が定義されていないということです。

メッセージ`function definition is void'の単語の使い方が少々変わってるの
は、Emacs Lispの実装方法に準じているのである。つまり、シンボルに関数定
義が与えられていない場合には、命令列を格納する場所は「void（空）」にな
るのである。

一方で、`(+ 2 2)'を評価すると2に2を加算できるので、シンボル`+'にはコン
ピュータが実行すべき命令列が与えられており、しかも、それらは`+'に続く数
を加算する命令であると推理できる。

Emacs 20やそれ以前のバージョンでは、以下のような1行のエラーメッセージし
か表示されません。そして、このメッセージはエコー領域に以下のように表示
されます。

     Symbol's function definition is void: this

このメッセージはカーソルを移動したり、何かキーをタイプするだけでメッセー
ジは消えてしまいます。

用語`Symbol'の意味は知っている。これは、リストの先頭要素である単語
`this'を意味する。用語`関数（function）'はコンピュータがすべき命令であ
ると述べた。（技術的には、シンボルは一連の命令を探す場所を指定するので
あるが、ここではその詳細は無視できる）。

エラーメッセージ`Symbol's function definition is void: this' の意味を理
解できるはずである。シンボル（つまり単語`this'）には、コンピュータが実
行すべき、命令が欠けているのである。



File: emacs-lisp-intro-ja.info, Node: Names & Definitions, Next: Lisp Interpreter, Prev: Making Errors, Up: List Processing

シンボル名と関数定義
====================

これまでに説明してきたことをもとに、Lispの別の特徴を明確にすることがで
きる。`+'のようなシンボルは、それ自身はコンピュータが実行すべき命令列で
はないという重要な特徴である。そのかわりに、定義、すなわち、命令列を探
すためにシンボルを（一時的に）使うのである。われわれが見ているものは、
命令列を探すための名前である。人の名前も同じように使われる。筆者は
`Bob'と呼ばれているが、私は`B'、`o'、`b'の3文字ではなく、意識のある生命
体である。名前そのものは私ではなく、私を指すために名前を使うのである。

Lispでは、1つの命令列に複数の名前を結び付けることができる。たとえば、コ
ンピュータの加算命令列をシンボル`plus'にも`+'にも結び付けられる（そのよ
うなLispの方言もある）。人間の世界でも、筆者を`Bob'と呼んだり`Robert'と
呼んだりでき、それ以外の単語でもよい。

その一方で、シンボルには1つの関数定義しか結び付けられない。さもなければ、
どちらの定義を採用すべきかコンピュータが混乱する。これを人間の世界に当
てはめると、`Bob'という名前を持つ人は世界中で1人に限られることになる。
しかし、名前が参照する関数定義を変更するのは容易である（*Note
Install::）。

Emacs Lispは巨大なので、関数が属するEmacsの構成部分がわかるようにシンボ
ルを命名する慣習がある。したがって、Texinfoを扱うすべての関数の名前は
`texinfo-'で始まり、メールを読むことに関連する関数の名前は`rmail-'で始
まる。



File: emacs-lisp-intro-ja.info, Node: Lisp Interpreter, Next: Evaluation, Prev: Names & Definitions, Up: List Processing

Lispインタープリタ
==================

これまでの説明をもとに、リストの評価をLispインタープリタに命じるとLisp
インタープリタが何をするかを理解することができる。まず、リストの直前に
クオートがあるかどうかを調べる。クオートがあれば、リストを返すだけであ
る。一方、クオートがなければ、インタープリタはリストの先頭要素を調べ、
それに関数定義があるかどうかを調べる。関数定義があれば、インタープリタ
はその関数定義内の命令列を実行する。さもなければ、インタープリタはエラー
メッセージを出力する。

これがLispの動作であり、単純である。すぐに説明するが、これに加えて複雑
なことがらもあるが、以上が基本である。当然、Lispプログラムを書くには、
関数定義の書き方、名前への結び付け方、および、これらを読者やコンピュー
タに混乱のないように行う方法を知る必要がある。

* Menu:

* Complications::               Variables, Special forms, Lists within.
* Byte Compiling::              Specially processing code for speed.



File: emacs-lisp-intro-ja.info, Node: Complications, Next: Byte Compiling, Prev: Lisp Interpreter, Up: Lisp Interpreter

Complications
-------------

では、複雑なことがらの最初のことを説明しよう。Lispインタープリタは、リ
ストに加えて、クオートもせず括弧で囲まれてもいないシンボルを評価できる。
Lispインタープリタは、"変数（variable）"としてのシンボルの値を決定しよ
うとする。これについては変数に関する節で説明する（*Note Variables::）。

複雑なことがらの2番目は、特殊な関数があり、これらは普通の方式のように動
作しないことである。これらを"スペシャルフォーム（special forms）"と呼ぶ。
関数の定義などの特殊なことを行うものであり、それらの個数は多くはない。
以下のいくつかの章では、重要なスペシャルフォームのいくつかを紹介する。

3番目で最後の複雑なことがらはつぎのとおりである。Lispインタープリタが探
しあてた関数がスペシャルフォームでなく、しかも、それがリストの一部であ
る場合には、Lispインタープリタはリストの内側にリストがあるかどうかを調
べる。内側にリストがあれば、Lispインタープリタは内側のリストを処理して
から、外側のリストを処理する。内側のリストの内側にもリストが含まれてい
る場合には、それを処理してから内側のリストを処理する。つねに、もっとも
内側のリストを最初に処理する。インタープリタはもっとも内側のリストの結
果を得るためにそれを処理する。その結果はそれを含む式で使われる。

そうでない場合には、インタープリタは左から右への順で式を1つずつ処理する。



File: emacs-lisp-intro-ja.info, Node: Byte Compiling, Prev: Complications, Up: Lisp Interpreter

バイトコンパイル
----------------

インタープリタには別の側面もある。Lispインタープリタは2種類のものを解釈
できる。本書で取り上げている人が読める形式のコードと、特別な処理を施し
人には読めない形式の"バイトコンパイル（byte compiled）"コードである。バ
イトコンパイルしたコードは、人間向けのコードに比べて実行が速い。

`byte-compile-file'のようなコンパイルコマンドを実行すれば、人間向けのコー
ドをバイトコンパイルコードに変換できる。バイトコンパイルコードは、拡張
子`.el'ではなく拡張子`.elc'で終わるファイルに収容するのが一般的である。
ディレクトリ`emacs/lisp'には両方の種類のファイルがあるが、読むのは拡張
子`.el'のファイルである。

実用上は、Emacsを調整したり拡張したりするのがほとんどであろうから、バイ
トコンパイルする必要はなく、ここではこれ以上取り上げない。バイトコンパ
イルについて詳しくは*Note Byte Compilation: (elisp)Byte Compilation。



File: emacs-lisp-intro-ja.info, Node: Evaluation, Next: Variables, Prev: Lisp Interpreter, Up: List Processing

評　価
======

Lispインタープリタが式を処理することを"評価する（evaluation）"と呼ぶ。
インタープリタが「式を評価する」という。これまでにも、この用語を何度か
使ってきた。この用語は日常の言葉使いからきている。つまり、`Webster's
New Collegiate Dictionary'によれば、「価値や量を見定める、見積もること」
である。

式を評価し終えると、Lispインタープリタは、関数定義で与えられた命令列を
コンピュータが実行した結果を"返す（return）"のが一般的であるが、関数の
処理を諦めてエラーメッセージを生成する場合もある（インタープリタ自体を
別の関数に渡したり、「無限ループ」と呼ばれる無制限に同じことを繰り返す
こともある。これらの動作は一般的ではないので、ここでは無視することにす
る）。ほとんどの場合、インタープリタは値を返す。

インタープリタは、値を返すと同時に、カーソルを移動したりファイルをコピー
したりなどの別の動作も行う。この種の別の動作は、"副作用（side effect）
と呼ばれる。結果の表示などの人間が重要と考える動作は、Lispインタープリ
タによっては「副作用」であることが多い。この用語は奇妙に聞こえるかもし
れないが、副作用の使い方を学ぶのはかなり簡単である。

まとめると、Lispインタープリタは、シンボリック式を評価するとほとんどの
場合は値を返すが、副作用を伴うこともある。あるいは、エラーを生成する。

* Menu:

* Evaluating Inner Lists::      Lists within lists...



File: emacs-lisp-intro-ja.info, Node: Evaluating Inner Lists, Prev: Evaluation, Up: Evaluation

内側のリストの評価
------------------

内側にリストを含んだリストを評価するときには、内側のリストを評価して得
られた値を、外側のリストを評価するときの情報として使う場合がある。その
ために、内側の式を最初に評価するのである。それが返した値を外側の式で使
用する。

このような評価の過程を、加算の例題で調べることにしよう。つぎの式の直後
にカーソルを置いて`C-x C-e'とタイプする。

     (+ 2 (+ 3 3))

エコー領域には数8が表示される。

Lispインタープリタで行われることは、まず内側の式`(+ 3 3)'を評価すること
であり、これは値6を返す。続いて、外側の式を`(+ 2 6)'であるかのように評
価し、これは値8を返す。評価すべき外側の式はもうないので、インタープリタ
はこの値をエコー領域に表示する。

さて、キー列`C-x C-e'で起動されるコマンドの名前を理解するのは容易である。
コマンドの名前は`eval-last-sexp'である。`sexp'は「シンボリック式
（symbolic expression）」の略、`eval'は「評価（evaluate）」の略である。
コマンドの意味は、「直前のシンボリック式を評価する」である。

式の直後の行の先頭や式の内側にカーソルを置いても式を評価できるかどうか
試してみよう。

つぎの式で試してみる。

     (+ 2 (+ 3 3))

式の直後の空行の先頭にカーソルを置いて`C-x C-e'とタイプしても、エコー領
域には値8が表示される。今度は、式の内側にカーソルを置いて試してみる。最
後の括弧のまえに（つまり、表示上は最後の括弧の上に）カーソルを置いて評
価すると、エコー領域には値6が表示される！　コマンドは式`(+ 3 3)'を評価
したからである。

今度は、数の直後にカーソルを置いてみる。`C-x C-e'とタイプすると数そのも
のを得る。Lispでは、数を評価するとその数そのものを得るのである。これが
数とシンボルの違いである。`+'のようなシンボルで始まるリストを評価すると、
`+'に結び付けた関数定義の命令列を実行した結果の値を得る。つぎの節で説明
するように、シンボルそのものを評価すると別のことが起こる。



File: emacs-lisp-intro-ja.info, Node: Variables, Next: Arguments, Prev: Evaluation, Up: List Processing

変　数
======

Emacs Lispでは、シンボルに関数定義を結び付けるように、シンボルに値を結
び付けることもできる。これらの2つは異なるものである。関数定義はコンピュー
タが遂行する命令列である。一方で、値は、数や名前などの何かであり、変更
できる（これが、そのようなシンボルが変数と呼ばれる理由である）。シンボ
ルの値としては、シンボル、数、リスト、文字列などのLispの任意の式を取れ
る。値を持つシンボルをしばしば"変数（variable）"と呼ぶ。

シンボルには関数定義と値の両方を同時に結び付けておくことができる。ある
いは一方か他方だけを結び付けておくことができる．これら2つは別々である。
これは、ケンブリッジという名称が、マサチューセッツの都市を表すと同時に、
「偉大なプログラミングセンター」のような名前の付加属性を持つことができ
るのに似ている。


あるいは、シンボルは箪笥であると考えてほしい。関数定義はある引き出しに
入れてあり、値は別の引き出しに入れてあるのである。関数定義を収めた引き
出しの中身を変えることなく、値を収めた引き出しの中身を変更でき、その逆
もそうである。

* Menu:

* fill-column Example::
* Void Function::               The error message for a symbol
                                  without a function.
* Void Variable::               The error message for a symbol without a value.



File: emacs-lisp-intro-ja.info, Node: fill-column Example, Next: Void Function, Prev: Variables, Up: Variables

`fill-column', an Example Variable
----------------------------------

値を持つシンボルの例として変数`fill-column'を取り上げよう。GNU Emacsの
各バッファでは、このシンボルに72とか70の値が設定されるが、それ以外の値
の場合もある。このシンボルの値を調べるには、それそのものを評価すればよ
い。GNU EmacsのInfoで読んでいる場合には、シンボルの直後にカーソルを置い
て`C-x C-e'とタイプする。

     fill-column

筆者の場合、`C-x C-e'とタイプするとEmacsはエコー領域に数72を表示する。
この値は、筆者が本書を執筆中に`fill-column'に設定してある値である。読者
のInfoバッファでは異なるかもしれない。変数の値として返された値は、関数
の命令列を実行した結果返された値とまったく同じように表示されることに注
意してほしい。Lispインタープリタの視点からは、どちらも返された値である。
値が求まってしまえば、それがどのような式から得られたかは関係ないのであ
る。

シンボルにはどのような値でも結び付けることができる。専門用語を使えば、
変数には、72のような数、`"such as this"'のような文字列、`(spruce pine
oak)'のようなリストを"束縛（bind）"できる。変数に関数定義を束縛すること
もできる。

シンボルに値を束縛する方法は何通りかある。1つの方法は、*Note set &
setq::。



File: emacs-lisp-intro-ja.info, Node: Void Function, Next: Void Variable, Prev: fill-column Example, Up: Variables

Error Message for a Symbol Without a Function
---------------------------------------------

`fill-column' を変数としての値を知るために評価するときには，単語の前後
に括弧は付けない．これは，関数として使うわけではないからである．

`fill-column'がリストの先頭要素だとすると、Lispインタープリタはこれに結
び付けられた関数定義を探そうとする。しかし、`fill-column'には関数定義は
ない。つぎを評価してみよう。

     (fill-column)

Emacs 21では，`*Backtrace*'バッファが表れ，以下のように表示されるだろう．

     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function fill-column)
       (fill-column)
       eval((fill-column))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------

(デバッガを停止させ、そこから抜けるために、`*Backtrace*' バッファで
`q' を入力することを思い出しなさい)

Emacs20やそれ以前もののでは、つぎのエラーメッセージを得る。

     Symbol's function definition is void: fill-column

(カーソルキーや他のキーを入力するとこのメッセージはすぐに消えてしまいま
す)



File: emacs-lisp-intro-ja.info, Node: Void Variable, Prev: Void Function, Up: Variables

値のないシンボルに対するエラーメッセージ
----------------------------------------

値が束縛されていないシンボルを評価すると、エラーメッセージを得る。たと
えば、2足す2の例を用いて調べてみよう。つぎの式で、最初の数2のまえの`+'
の直後にカーソルを置いて`C-x C-e'をタイプすると、

     (+ 2 2)

Emacs 21では`*Backtrace*'バッファに以下のように表示されます．

     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-variable +)
       eval(+)
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------

(他の時同様，デバッガに入った時には，`*Backtrace*'バッファで`q' を入力
することでデバッガから出ることができます)

これはまえに見た`Symbol's function definition is void: this'とは違うエ
ラーメッセージである。ここでは、シンボルには変数としての値がないのであ
る。まえの場合は、（`this'という）シンボルには関数定義がなかったのであ
る。

`+'で試したことは、Lispインタープリタに`+'を評価させて、関数定義ではな
く変数の値を探させたのである。そうするために、式を閉じる括弧の直後にカー
ソルを置くかわりに、シンボルの直後にカーソルを置いた。そのため、Lispイ
ンタープリタは直前のS式、つまり、`+'そのものを評価したのである。

`+'には、関数定義はあるが、値は束縛されていないので、変数としてのシンボ
ルの値は空（void）である旨のエラーメッセージが報告されたのである。

Emacs 20やそれ以前のものでは，つぎのエラーメッセージを得る。

     Symbol's value as variable is void: +

意味はEmacs 21と同じである．



File: emacs-lisp-intro-ja.info, Node: Arguments, Next: set & setq, Prev: Variables, Up: List Processing

引　数
======

どのように関数に情報が伝えられるかを見るために、お馴染みの2足す2の例を
使ってみよう。Lispでは、つぎのように書く。

     (+ 2 2)

この式を評価すると、エコー領域には数4が表示される。Lispインタープリタが
行ったことは、`+'のあとに続く数の加算である。

`+'が加算した数のことを、関数`+'の"引数（arguments）"と呼ぶ。これらの数
は、関数に与えられた、つまり、"渡された"情報である。

「argument（引数）」という用語は数学での用法からきており、2人のあいだの
議論のことではない。ここでは、`+'という関数へ与えられた情報を意味する。
Lispでは、関数に対する引数は、その関数のあとに続くアトムやリストである。
これらのアトムやリストを評価して返された値が関数へ渡される。関数が異な
れば、必要な引数の個数も異なり、引数をまったく必要としない関数もある。
(1) (*Note Arguments-Footnotes::)

* Menu:

* Data types::                  Types of data passed to a function.
* Args as Variable or List::    An argument can be the value
                                  of a variable or list.
* Variable Number of Arguments::  Some functions may take a
                                  variable number of arguments.
* Wrong Type of Argument::      Passing an argument of the wrong type
                                  to a function.
* message::                     A useful function for sending messages.


File: emacs-lisp-intro-ja.info  Node: Arguments-Footnotes, Up: Arguments

(1) 単語「argument」の異なる2つの意味、つまり、数学での意味と日常語での
意味がどのように成立したかを調べると興味深い。`Oxford English
Dictionary'によれば、`to make clear, prove （明らかにする、証明す
る）'を意味するラテン語が語源である。これから、「証明として与えられた証
拠」という一方の意味が派生して、「与えられた情報」を意味するようになり、
Lispでの意味になるのである。もう一方の意味としては、「ある仮定とは反対
の仮定をする」を意味するようになり、議論するという意味になったのである
（英語では異なる2つの意味が同時に1つの単語に与えられている。対照的に、
Emacs Lispでは、異なる2つの関数定義を同時にシンボルに与えることはできな
い）。



File: emacs-lisp-intro-ja.info, Node: Data types, Next: Args as Variable or List, Prev: Arguments, Up: Arguments

引数のデータ型
--------------

関数に渡すデータの型は、関数が使用する情報の種類に応じて決まる。`+'は数
を加算するので、`+'のような関数への引数は数値である必要がある。別の関数
では別の種類のデータの引数が必要である。

たとえば、関数`concat'は複数の文字列を繋いで1つの文字列を生成する。した
がって、引数は文字列である。文字列`abc'と`def'を繋ぐ（concatinate）と、
1つの文字列`abcdef'が作られる。これはつぎの式を評価するとわかる。

     (concat "abc" "def")

この式を評価して得られる値は`"abcdef"'である。

`substring'のような関数は、引数として文字列と数を取る。この関数は文字列
の一部分、つまり、第1引数の部分文字列を返す。この関数は3つの引数を取る。
第1引数は文字列であり、第2引数と第3引数は数で、部分文字列の開始位置と終
了位置を示す。これらの数は、文字列の先頭からの（空白や句読点を含む）文
字の個数である。

たとえば、つぎを評価すると、

     (substring "The quick brown fox jumped." 16 19)

エコー領域には`"fox"'と表示される。引数は、1つの文字列と2つの数である。

`substring'に渡された文字列は、空白で区切られた複数の単語ではあるが1つ
のアトムである。Lispは、2つの二重引用符のあいだにあるものを、たとえ空白
があいだにあっても文字列として扱う。関数`substring'は、他の方法では不可
分なアトムから一部分を切り出すので、「アトム粉砕機」の一種と考えてもよ
い。しかし、`substring'は、文字列である引数から部分文字列を切り出すこと
ができるだけであり、数やシンボルなどのそれ以外の種類のアトムは扱えない。



File: emacs-lisp-intro-ja.info, Node: Args as Variable or List, Next: Variable Number of Arguments, Prev: Data types, Up: Arguments

引数としての変数やリストの値
----------------------------

引数は、評価したときに値を返すシンボルでもよい。たとえば、シンボル
`fill-column'そのものを評価すると数を返す。この数は加算に使える。

つぎの式のうしろにカーソルを置いて`C-x C-e'とタイプする。

     (+ 2 fill-column)

`fill-column'を単独で評価した値より2だけ大きな値が得られる。筆者の場合
には、`fill-column'の値は72なので、結果は74である。

このように、評価すると値を返すシンボルを引数に使えるのである。
さらに、評価すると値を返すリストを引数に使うこともできる。
たとえば、つぎの式では、関数`concat'への引数は、
文字列`"The "'と`" red foxes."'、
さらに、リスト`(number-to-string (+ 2 fill-column))'である。

     (concat "The " (number-to-string (+ 2 fill-column)) " red foxes.")

この式を評価すると、(もし私のEmacsのように `fill-column' が 72 になって
いれば) エコー領域には`"The 74 red foxes."'と表示される（最終結果の文字
列に空白が含まれるように、単語`The'の直後と単語`red'の直前には空白が必
要である．関数`number-to-string' は加算関数が返す整数を文字に変換する．
`number-to-string' は `int-to-string' でも同じである）。



File: emacs-lisp-intro-ja.info, Node: Variable Number of Arguments, Next: Wrong Type of Argument, Prev: Args as Variable or List, Up: Arguments

可変個数の引数
--------------

`concat'、`+'、`*'などのある種の関数は、任意個数の引数を取る（`*'は乗算
のシンボルである）。これは、以下の式のおのおのを通常の方法で評価すると
わかる。`=>'のあとのテキストがエコー領域に表示され、`=>'は「の評価結果
は」と読めばよい。

まず、関数に引数がない場合にはつぎのとおりである。

     (+)       => 0

     (*)       => 1

つぎは、関数に引数が1つの場合である。

     (+ 3)     => 3

     (* 3)     => 3

今度は、関数に引数が3つある場合である。

     (+ 3 4 5) => 12

     (* 3 4 5) => 60



File: emacs-lisp-intro-ja.info, Node: Wrong Type of Argument, Next: message, Prev: Variable Number of Arguments, Up: Arguments

引数に誤った型のオブジェクトを指定
----------------------------------

誤った型の引数を関数へ渡すと、Lispインタープリタはエラーメッセージを生
成する。たとえば、関数`+'は引数として数を仮定する。数のかわりにクオート
したシンボル`hello'を与えてみよう。つぎの式の直後にカーソルを置いて
`C-x C-e'とタイプする。

     (+ 2 'hello)

そうすると、エラーメッセージを得る。何が起こったかというと、`+'は数2に
`'hello'が返す値を加算しようとしたのだが、`'hello'が返した値はシンボル
`hello'であり、数ではない。加算できるのは数のみである。したがって、`+'
は加算を実行できなかったのである。

Emacs 21では `*Backtrace*' に以下のように表示される．

     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error:
              (wrong-type-argument number-or-marker-p hello)
       +(2 hello)
       eval((+ 2 (quote hello)))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------

普通、エラーメッセージは有用なようになっているので、読み方がわかれば意
味がわかる。

エラーメッセージの最初の部分は簡単で、
`Wrong type argument'、つまり、引数の型がまちがっているである。
つぎは、不思議な専門用語で`number-or-marker-p'である。
これは、`+'が仮定する引数の種類を伝えようとしているのである。

シンボル`number-or-marker-p'の意味は、Lispインタープリタが渡された情報
（引数の値）が整数（数）かマーカー（バッファ内の位置を表す特殊なオブジェ
クト）かどうかを調べようとしているということである。つまり、加算すべき
整数が`+'に与えられたかどうかを検査したのである。このとき、引数が、
Emacs Lispに特有の機能であるマーカーかどうかも検査する（Emacsでは、バッ
ファ内の位置をマーカーで記録する。コマンド`C-@'や`C-SPC'でマークを設定
すると、その位置はマーカーとして保存される。マークは数として扱うことが
でき、バッファの先頭からのその位置までの文字の個数である）。Emacs Lisp
では、`+'でマーカー位置の数値を数として加算できる。

`number-or-marker-p'の`p'は、Lispプログラミングの早い時期に始まった慣習
である。`p'は「述語（predicate）」の略である。初期のLisp研究者が用いた
専門用語では、述語とはある性質が真か偽か調べる関数を意味する。したがっ
て、`p'があることで、`number-or-marker-p'は、与えられた引数が数であるか
マーカーであるかの真偽を調べる関数の名前であることがわかる。`p'で終わる
そのほかのLispシンボルには、引数の値が0であるかを調べる関数`zerop'、引
数がリストであるかを調べる関数`listp'がある。


エラーメッセージの最後の部分はシンボル`hello'である。これは`+'に渡され
た引数の値である。正しい型のオブジェクトが加算に渡されれば、渡された値
は`hello'のようなシンボルではなく37のような数であるはずである。そうであっ
たならば、エラーメッセージが表示されることはなかったのである。

Emacs 20やそれ以前のものでは，エコー領域に以下のように表示されます．

     Wrong type argument: number-or-marker-p, hello

これは，言い方を変えると，`*Backtrace*' バッファの先頭行のようなものと
言うことができる．



